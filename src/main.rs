use std::env;
use std::fs::File;
use std::io::prelude::*;

use sexp::Atom::*;
use sexp::*;

use im::HashMap;
use std::collections::HashSet;

const TRUE_INT :i64 = 7;
const FALSE_INT :i64 = 3;
const INT_ONE :i64 = 2;
const NIL_INT :i64 = 1;

const ARRAY_TAG_INT: i64 = 1;
// const DEFAULT_VALUE_INT: i64 = 9; // todo: check

const I63_MAX : i64 = 4611686018427387903;
const I63_MIN : i64 = -4611686018427387904;

static ALL_RESERVED_WORDS: &'static [&str] = &["true", "false", "add1", "sub1", "isnum", 
                                      "isbool", "input" ,"let", "block", "set", "if", "break", 
                                      "loop", "set!", "+", "-", "*", "=", ">", ">=", "<", "<="];


#[derive(Debug, Clone)]
struct Program {
  defs: Vec<Definition>,
  main: Expr,
}

#[derive(Debug, Clone)]
struct Definition {
  fun_name: String, 
  args: Vec<String>, 
  fun_body: Option<Expr>,
}

#[derive(Debug, Clone)]
enum Val {
    Reg(Reg),
    ImmInt(i64),
    // ImmString(String),
    RegPlusOffset(Reg, i32),
    RegNegOffset(Reg, i32),
}

#[derive(Debug, Clone)]
enum Reg {
    RAX,
    RBX,
    RSP,
    RDI,
    RSI,
    R15,
    RCX,
}

#[derive(Debug, Clone)]
enum Instr {
    IMov(Val, Val),
    IAdd(Val, Val),
    ISub(Val, Val),
    IMul(Val, Val),
    ICmp(Val, Val),
    IXor(Val, Val),
    IOr(Val, Val),
    ITest(Val, Val),
    ICmove(Val, Val),
    // IAnd(Val, Val),
    IJg(String),
    IJge(String),
    IJl(String),
    IJle(String),
    ILabel(String, Vec<Instr>),
    IJe(String),
    IJmp(String),
    // IJne(String),
    // IPush(Val),
    // IPop(Val),
    // IJz(String),
    // IJnz(String),
    // ILoop(String), 
    // IBreak(Val),
    IRet(),
    ISar(Val, u64), 
    ISal(Val, u64), 
    IJc(String), 
    ICall(String),
    IJnc(String),
    IJo(String),
    ICmovb(Val, Val),
    IComment(String),
    // IString(String),

}

#[derive(Debug, Clone)]
enum Op1 {
    Add1,
    Sub1,
    IsNum, 
    IsBool,
    IsNil,
    Print,
}

#[derive(Debug, Clone)]
enum Op2 {
    Plus,
    Minus,
    Times,
    Equal, 
    StructuralEquality,
    Greater, 
    GreaterEqual, 
    Less, 
    LessEqual,
    CheckTypeMatch,
}

#[derive(Clone, Debug)]
enum Expr {
    Number(i64),
    True, 
    False,
    Input,
    Nil,
    Id(String),
    Let(Vec<(String, Expr)>, Box<Expr>),
    UnOp(Op1, Box<Expr>),
    BinOp(Op2, Box<Expr>, Box<Expr>),
    Set(String, Box<Expr>),
    If(Box<Expr>, Box<Expr>, Box<Expr>), 
    Block(Vec<Expr>), 
    Loop(Box<Expr>), 
    Break(Box<Expr>),

    Function(String, Vec<Expr>),
    Array(Vec<Expr>),
    GetArrayIndex(Box<Expr>, Box<Expr>),
    SetArrayIndex(Box<Expr>, Box<Expr>, Box<Expr>),
    GetArraySize(Box<Expr>),
}

//helpers
fn depth(e: &Expr) -> i32 {
  match e {
    // write code to find the depth of each expr
    Expr::Number(_) => 0,
    Expr::True => 0,
    Expr::False => 0,
    Expr::Input => 0,
    Expr::Nil => 0,
    Expr::Id(_) => 0,
    Expr::Let(bindings, body) => {
      // enumerate bindings and find the max of depth(binding) + enumeration value and depth(body) + enumeration from bindings  + 1
      bindings.iter().enumerate().map(|(i, (_, expr))| depth(expr) + (i as i32)).max()
                .unwrap_or(0).max(depth(body) + bindings.len() as i32)
    },
    Expr::UnOp(_, expr) => depth(expr),
    Expr::BinOp(_, expr1, expr2) => depth(expr1).max(depth(expr2) + 1),
    Expr::Set(_, expr) => depth(expr),
    Expr::If(expr1, expr2, expr3) => depth(expr1).max(depth(expr2)).max(depth(expr3)),
    Expr::Block(exprs) => exprs.iter().map(|expr| depth(expr)).max().unwrap_or(0),
    Expr::Loop(expr) => depth(expr),
    Expr::Break(expr) => depth(expr),
    // for Expr::Function enumerate and find the max of depth(expr) + enumeration value
    Expr::Function(_, exprs) => exprs.iter().enumerate().map(|(i, expr)| depth(expr) + (i as i32)).max().unwrap_or(0),
    // todo: update, check function also
    Expr::Array(exprs) => exprs.iter().enumerate().map(|(i, expr)| depth(expr) + (i as i32) + 2).max().unwrap_or(0),
    Expr::GetArrayIndex(addr_expr, index_expr) => depth(addr_expr).max(depth(index_expr) + 1),
    Expr::SetArrayIndex(addr_expr, index_expr, value_expr) => depth(addr_expr).max(depth(index_expr) + 1).max(depth(value_expr) + 2),
    Expr::GetArraySize(addr_expr) => depth(addr_expr) + 1,
  }
}

fn new_label(l: &mut i32, s: &str) -> String {
  let current = *l;
  *l += 1;
  format!("{s}_{current}")
}

// generated by GPT
fn has_input_type(expr: &Expr) -> bool {
  match expr {
      Expr::Number(_) => false,
      Expr::True => false,
      Expr::False => false,
      Expr::Input => true,
      Expr::Nil => false,
      Expr::Id(_) => false,
      Expr::Let(bindings, body) => {
          let mut has_input = false;
          for (_, expr) in bindings.iter() {
              has_input |= has_input_type(expr);
          }
          has_input |= has_input_type(body);
          has_input
      }
      Expr::UnOp(_, expr) => has_input_type(expr),
      Expr::BinOp(_, lhs, rhs) => {
          has_input_type(lhs) || has_input_type(rhs)
      }
      Expr::Set(_, expr) => has_input_type(expr),
      Expr::If(cond, then_expr, else_expr) => {
          has_input_type(cond)
              || has_input_type(then_expr)
              || has_input_type(else_expr)
      }
      Expr::Block(exprs) => {
          let mut has_input = false;
          for expr in exprs.iter() {
              has_input |= has_input_type(expr);
          }
          has_input
      }
      Expr::Loop(expr) => has_input_type(expr),
      Expr::Break(expr) => has_input_type(expr),
      Expr::Function(_, args) => {
          let mut has_input = false;
          for arg in args.iter() {
              has_input |= has_input_type(arg);
          }
          has_input
      },
      Expr::Array(exprs) => {
          let mut has_input = false;
          for expr in exprs.iter() {
              has_input |= has_input_type(expr);
          }
          has_input
      },
      Expr::GetArrayIndex(addr_expr, index_expr) => {
          has_input_type(addr_expr) || has_input_type(index_expr)
      },
      Expr::SetArrayIndex(addr_expr, index_expr, value_expr) => {
          has_input_type(addr_expr)
              || has_input_type(index_expr)
              || has_input_type(value_expr)
      },
      Expr::GetArraySize(addr_expr) => has_input_type(addr_expr),
  }
}

// type check and overflow helpers 


fn check_overflow(_v: Val) -> Vec<Instr> {
  let mut instr_vect = Vec::new();
  instr_vect.push(Instr::IJo("throw_overflow_error".to_string()));
  instr_vect
}

fn check_if_num(v: Val) -> Vec<Instr> {
  let mut instr_vect = Vec::new();
  instr_vect.push(Instr::IComment("check if num".to_string()));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v));
  instr_vect.push(Instr::ISar(Val::Reg(Reg::RBX), 1)); // should have 0
  instr_vect
}

fn check_input_num(v: Val) -> Vec<Instr> {
  let mut instr_vect = check_if_num(v);
  instr_vect.push(Instr::IComment("check if input num".to_string()));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(TRUE_INT)));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), Val::ImmInt(FALSE_INT)));
  instr_vect.push(Instr::ICmovb(Val::Reg(Reg::RAX), Val::Reg(Reg::RBX)));
  instr_vect
}

fn is_num(v: Val) -> Vec<Instr> {
  let mut instr_vect = check_if_num(v);
  instr_vect.push(Instr::IJc("throw_error".to_string()));
  instr_vect
}

fn check_input_bool(v: Val) -> Vec<Instr> {
  let mut instr_vect = check_if_bool(v);
  instr_vect.push(Instr::IComment("check if input bool".to_string()));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), Val::ImmInt(TRUE_INT)));
  instr_vect.push(Instr::ICmovb(Val::Reg(Reg::RAX), Val::Reg(Reg::RBX)));
  instr_vect
}

fn check_if_bool(v: Val) -> Vec<Instr> {
  let mut instr_vect = Vec::new();
  instr_vect.push(Instr::IComment("check if bool".to_string()));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v));
  instr_vect.push(Instr::ISar(Val::Reg(Reg::RBX), 1)); // should have 1
  instr_vect
}

fn error_if_type_mismatch(v1: Val, v2: Val, match_end_label: &String) -> Vec<Instr> {
  let mut instr_vect = Vec::new();
  instr_vect.push(Instr::IComment("check_type_match_result".to_string()));

  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v1.clone()));
  instr_vect.push(Instr::IXor(Val::Reg(Reg::RBX), v2.clone()));
  instr_vect.push(Instr::ITest(Val::Reg(Reg::RBX), Val::ImmInt(3)));
  instr_vect.push(Instr::IJe(match_end_label.to_string())); // jz -> all matched

  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v1));
  instr_vect.push(Instr::IOr(Val::Reg(Reg::RBX), v2));
  instr_vect.push(Instr::ITest(Val::Reg(Reg::RBX), Val::ImmInt(1)));
  instr_vect.push(Instr::IJe(match_end_label.to_string())); // last digit is 0

  instr_vect.push(Instr::IJmp("throw_error".to_string()));
  instr_vect
}

fn check_type_match_result(v1: Val, v2: Val, match_end_label: &String) -> Vec<Instr> {
  let mut instr_vect = Vec::new();
  instr_vect.push(Instr::IComment("check_type_match_result".to_string()));

  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v1.clone()));
  instr_vect.push(Instr::IXor(Val::Reg(Reg::RBX), v2.clone()));
  instr_vect.push(Instr::ITest(Val::Reg(Reg::RBX), Val::ImmInt(3)));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(TRUE_INT)));
  instr_vect.push(Instr::IJe(match_end_label.to_string())); // jz -> all matched

  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v1));
  instr_vect.push(Instr::IOr(Val::Reg(Reg::RBX), v2));
  instr_vect.push(Instr::ITest(Val::Reg(Reg::RBX), Val::ImmInt(1)));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(TRUE_INT)));
  instr_vect.push(Instr::IJe(match_end_label.to_string())); // last digit is 0 for both

  instr_vect.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
  instr_vect
}

// array helpers
fn check_if_nil(v: Val) -> Vec<Instr> {
  let mut instr_vect = Vec::new();
  instr_vect.push(Instr::IComment("check if nil".to_string()));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v));
  instr_vect.push(Instr::ICmp(Val::Reg(Reg::RBX), Val::ImmInt(NIL_INT)));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), Val::ImmInt(TRUE_INT)));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
  instr_vect.push(Instr::ICmove(Val::Reg(Reg::RAX), Val::Reg(Reg::RBX)));
  instr_vect
}
fn access_array_index_addr(si: i32) -> Vec<Instr> {
  let mut instr_vector = Vec::new();
  let stack_offset = si * 8;

  instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::RegNegOffset(Reg::RSP, stack_offset))); // address value
  instr_vector.push(Instr::IMov(Val::Reg(Reg::RBX), Val::RegNegOffset(Reg::RAX, 0))); // actual value = size of array

  instr_vector.push(Instr::ICmp(Val::RegNegOffset(Reg::RSP, stack_offset + 8), Val::Reg(Reg::RBX))); // index vs size

  instr_vector.push(Instr::IJg("throw_index_out_of_bounds_error".to_string()));

  instr_vector.push(Instr::IMov(Val::Reg(Reg::RBX), Val::RegNegOffset(Reg::RSP, stack_offset + 8)));
  instr_vector.push(Instr::IMul(Val::Reg(Reg::RBX), Val::ImmInt(8)));
  instr_vector.push(Instr::IAdd(Val::Reg(Reg::RBX), Val::Reg(Reg::RAX)));

  return instr_vector;
}

fn evaluate_addr(si: i32, addr_expr: &Expr, env: & HashMap<String, i32>, break_label: &String, l: &mut i32) -> Vec<Instr> {
  let mut instr_vector = Vec::new();
  let stack_offset = si * 8;

  instr_vector.extend(compile_expr(addr_expr, si, &env, &break_label, l)); // addr value in RAX
  instr_vector.extend(is_array(Val::Reg(Reg::RAX)));
  instr_vector.push(Instr::ISub(Val::Reg(Reg::RAX), Val::ImmInt(ARRAY_TAG_INT)));
  instr_vector.push(Instr::IMov(Val::RegNegOffset(Reg::RSP, stack_offset), Val::Reg(Reg::RAX))); // addr value without tag

  return instr_vector;
}

fn evaluate_addr_and_index_array(si: i32, addr_expr: &Expr, index_expr: &Expr, env: & HashMap<String, i32>, break_label: &String, l: &mut i32) -> Vec<Instr> {
  let mut instr_vector = Vec::new();
  let stack_offset = si * 8;

  instr_vector.extend(evaluate_addr(si, addr_expr, &env, &break_label, l));
  
  instr_vector.extend(compile_expr(index_expr, si + 1, &env, &break_label, l)); 
  instr_vector.extend(is_num(Val::Reg(Reg::RAX)));

  instr_vector.push(Instr::ICmp(Val::Reg(Reg::RAX), Val::ImmInt(0)));
  instr_vector.push(Instr::IJle("throw_index_out_of_bounds_error".to_string()));

  instr_vector.push(Instr::ISar(Val::Reg(Reg::RAX), 1)); // to get num represen without tag
  instr_vector.push(Instr::IMov(Val::RegNegOffset(Reg::RSP, stack_offset + 8), Val::Reg(Reg::RAX))); // index value in RBX

  return instr_vector;
}

fn is_array(v: Val) -> Vec<Instr> {
  let mut instr_vect = Vec::new();
  instr_vect.push(Instr::IComment("check if array".to_string()));
  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v.clone()));
  instr_vect.push(Instr::ISar(Val::Reg(Reg::RBX), 1)); // last bit should be 1
  instr_vect.push(Instr::IJnc("throw_error".to_string()));
  instr_vect.push(Instr::ISar(Val::Reg(Reg::RBX), 1)); // 2nd last bit should be 0
  instr_vect.push(Instr::IJc("throw_error".to_string()));

  instr_vect.push(Instr::IMov(Val::Reg(Reg::RBX), v.clone()));
  instr_vect.push(Instr::ICmp(Val::Reg(Reg::RBX), Val::ImmInt(NIL_INT)));
  instr_vect.push(Instr::IJe("throw_error".to_string()));

  instr_vect
}

// instr to string helpers
fn instr_to_str(i: &Instr) -> String {
  match i {
      Instr::IMov(v1, v2) => format!("mov {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::IAdd(v1, v2) => format!("add {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::ISub(v1, v2) => format!("sub {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::IMul(v1, v2) => format!("imul {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::ICmp(v1, v2) => format!("cmp {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::ICmove(v1, v2) => format!("cmove {}, {}", val_to_str(v1), val_to_str(v2)),
      // Instr::IAnd(v1, v2) => format!("and {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::IJg(label) => format!("jg {}", label),
      Instr::IJge(label) => format!("jge {}", label),
      Instr::IJl(label) => format!("jl {}", label),
      Instr::IJle(label) => format!("jle {}", label),
      Instr::ICall(fun_name) => format!("call {}", fun_name),
      // Instr::IString(val) => format!("{}", val),
      // Instr::IPush(v1) => format!("push {}", val_to_str(v1)),
      // Instr::IPop(v1) => format!("pop {}", val_to_str(v1)),
      // Instr::IJz(label) => format!("jz {}", label),
      // Instr::IJnz(label) => format!("jnz {}", label),
      Instr::ILabel(label, instrs) => format!("{}:{}", label, decode_instrs_vec_to_string(instrs)),
      Instr::IJe(label) => format!("je {}", label),
      Instr::IJc(label) => format!("jc {}", label),
      Instr::IJo(label) => format!("jo {}", label),
      Instr::IJnc(label) => format!("jnc {}", label),
      Instr::ISar(v1, bits) => format!("sar {}, {}", val_to_str(v1), bits),
      Instr::ISal(v1, bits) => format!("sal {}, {}", val_to_str(v1), bits),
      Instr::IJmp(label) => format!("jmp {}", label),
      // Instr::IJne(label) => format!("jne {}", label),
      Instr::IXor(v1, v2) => format!("xor {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::IOr(v1, v2) => format!("or {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::ITest(v1, v2) => {
        match v1 {
          Val::RegNegOffset(_, _) | Val::RegPlusOffset(_, _) => format!("test word{}, {}", val_to_str(v1), val_to_str(v2)),
          _ => format!("test {}, {}", val_to_str(v1), val_to_str(v2))
        }
      },
      // Instr::ILoop(label) => format!("loop {}", label),
      // Instr::IBreak(v1) => format!("break {}", val_to_str(v1)),
      Instr::ICmovb(v1, v2) => format!("cmovb {}, {}", val_to_str(v1), val_to_str(v2)),
      Instr::IComment(comment) => format!("\t\t; {}", comment),
      Instr::IRet() => format!("ret\n"),
  }
}

fn reg_str(reg_name: &Reg) -> String {
  match reg_name {
      Reg::RAX => "rax", 
      Reg::RSP => "rsp", 
      Reg::RBX => "rbx", 
      Reg::RDI => "rdi", 
      Reg::RSI => "rsi", 
      Reg::R15 => "r15",
      Reg::RCX => "rcx",
  }.to_string()
}

fn val_to_str(v: &Val) -> String {
  match v {
      Val::Reg(reg_name) => {
        reg_str(reg_name)
      },
      Val::ImmInt(num) => num.to_string(),
      // Val::ImmString(address) => address.to_string(),
      Val::RegNegOffset(reg_name, stack_offset) => {
          let reg_name = reg_str(reg_name);
          format!("[{} - {}]", reg_name, stack_offset)
      },
      Val::RegPlusOffset(reg_name, stack_offset) => {
        let reg_name = reg_str(reg_name);
        format!("[{} + {}]", reg_name, stack_offset)
    },
  }
}

fn decode_instrs_vec_to_string(vect_instrs: &Vec<Instr>) -> String {
let mut ans = "".to_owned();
for inst in vect_instrs.iter() {
    ans += &("\n".to_owned() + &instr_to_str(&inst));
    // ans.push_str("\n");
    // ans.push_str(&instr_to_str(&inst));
}
ans.to_string()
}

// -------

// compiling
 
fn compile_expr(e: &Expr, si: i32, env: & HashMap<String, i32>, break_label: &String, l: &mut i32) -> Vec<Instr> {
    let mut instr_vector = Vec::new();
    instr_vector.push(Instr::IComment(format!("compile_expr {:?}", e)));
    match e {
        Expr::Number(n) => {
            instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(*n)));
            instr_vector.extend(check_overflow(Val::Reg(Reg::RAX)));
        }, 
        Expr::True => {
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(TRUE_INT)))
        },
        Expr::False => {
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)))
        },
        Expr::Input => {
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::Reg(Reg::RDI)));
          instr_vector.extend(check_overflow(Val::Reg(Reg::RAX)))
        },
        Expr::Nil => {
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(NIL_INT)));
        }
        Expr::Id(s) => {
            println!("env {:?}, s = {}", *env, s);
            if env.contains_key(s) {
                instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::RegPlusOffset(Reg::RSP, *env.get(s).unwrap())))
            } else {
                panic!("Unbound variable identifier {}", s);
            }
        },
        Expr::Let(binding, body) => {
            let mut nenv = env.clone();
            let mut si_local = si;
            let mut current_binding = HashSet::new();
            if binding.len() < 1 {
                panic!("Invalid");
            }
            for (var_id, value) in binding.iter() {
                println!("compile_expr - {}", var_id);
                if current_binding.contains(var_id) {
                    panic!("Duplicate binding");
                }
                current_binding.insert(var_id);
                let binding_expr_instrs = compile_expr(value, si_local, &nenv, &break_label, l);
                nenv = nenv.update(var_id.to_string(), si_local * 8);
                println!("nenv {:?}", nenv);
                instr_vector.extend(binding_expr_instrs);
                let curr_instr = Instr::IMov(Val::RegPlusOffset(Reg::RSP, si_local * 8), Val::Reg(Reg::RAX));
                instr_vector.push(curr_instr);
                si_local += 1;
            }

            let body_instrs = compile_expr(body, si_local, &nenv, &break_label, l);
            instr_vector.extend(body_instrs);
        }, 
        Expr::UnOp(op1, subexp) => {
            let subexp_instrs = compile_expr(subexp, si, &env, &break_label, l);
            instr_vector.extend(subexp_instrs);
            match op1 {
                Op1::Add1 => {
                  let v1 = Val::Reg(Reg::RAX);
                  let v2 = Val::ImmInt(INT_ONE);
                  instr_vector.extend(is_num(v1.clone()));
                  instr_vector.extend(is_num(v2.clone()));
                  instr_vector.push(Instr::IAdd(v1.clone(), v2.clone()));
                  instr_vector.extend(check_overflow(v1.clone()));
                }
                Op1::Sub1 => {
                  let v1 = Val::Reg(Reg::RAX);
                  let v2 = Val::ImmInt(INT_ONE);
                  instr_vector.extend(is_num(v1.clone()));
                  instr_vector.extend(is_num(v2.clone()));
                  instr_vector.push(Instr::ISub(v1.clone(), v2.clone()));
                  instr_vector.extend(check_overflow(v1.clone()));
                }
                Op1::IsNum => {
                  instr_vector.extend(check_input_num(Val::Reg(Reg::RAX)));
                },
                Op1::IsBool => {
                  instr_vector.extend(check_input_bool(Val::Reg(Reg::RAX)));
                },
                Op1::IsNil => {
                  instr_vector.extend(check_if_nil(Val::Reg(Reg::RAX)));
                },
                Op1::Print => {
                  let index = if si % 2 == 1 { si + 2 } else { si + 3 };
                  let offset = index * 8;

                  let rdi_offset = 0;

                  instr_vector.push(Instr::ISub(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));

                  instr_vector.push(Instr::IMov(Val::RegPlusOffset(Reg::RSP, rdi_offset), Val::Reg(Reg::RDI)));
        
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RDI), Val::Reg(Reg::RAX)));
        
                  instr_vector.push(Instr::ICall("snek_print".to_owned()));
        
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RDI), Val::RegPlusOffset(Reg::RSP, rdi_offset)));

                  instr_vector.push(Instr::IAdd(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));                  
                }
            };
        }, 
        Expr::BinOp(op2, subexp1, subexp2) => {
            let e1_instrs = compile_expr(subexp1, si, &env, &break_label, l);
            let e2_instrs = compile_expr(subexp2, si+1, &env, &break_label, l);
            let stack_offset = si * 8;
            instr_vector.extend(e1_instrs);
            instr_vector.push(Instr::IMov(Val::RegNegOffset(Reg::RSP, stack_offset), Val::Reg(Reg::RAX)));
            instr_vector.extend(e2_instrs);

            match op2 {
                Op2::Plus => {
                  let v1 = Val::Reg(Reg::RAX);
                  let v2 = Val::RegNegOffset(Reg::RSP, stack_offset);
                  instr_vector.extend(is_num(v1.clone()));
                  instr_vector.extend(is_num(v2.clone()));
                  // instr_vector.push(Instr::IRet());
                  instr_vector.push(Instr::IAdd(v1.clone(), v2.clone()));
                  instr_vector.extend(check_overflow(v1.clone()));
                }
                Op2::Minus => {
                  let v1 = Val::RegNegOffset(Reg::RSP, stack_offset);
                  let v2 = Val::Reg(Reg::RAX);
                  instr_vector.extend(is_num(v1.clone()));
                  instr_vector.extend(is_num(v2.clone()));
                  instr_vector.push(Instr::ISub(v1.clone(), v2.clone()));
                  instr_vector.push(Instr::IMov(v2.clone(), v1.clone()));
                  instr_vector.extend(check_overflow(v2.clone()));
                }
                Op2::Times => {
                  let v1 = Val::Reg(Reg::RAX);
                  let v2 = Val::RegNegOffset(Reg::RSP, stack_offset);
                  instr_vector.extend(is_num(v1.clone()));
                  instr_vector.extend(is_num(v2.clone()));
                  instr_vector.push(Instr::ISar(v1.clone(), 1));
                  instr_vector.push(Instr::IMul(v1.clone(), v2.clone()));
                  // instr_vector.push(Instr::IRet()); 
                  instr_vector.extend(check_overflow(v1.clone()));
                }
                Op2::Equal => {
                    let v1 = Val::Reg(Reg::RAX);
                    let v2 = Val::RegNegOffset(Reg::RSP, stack_offset);
                    let match_end_label = new_label(l, "equal_type_match_end");
                    instr_vector.extend(error_if_type_mismatch(v1.clone(), v2.clone(), &match_end_label));
                    instr_vector.push(Instr::ILabel(match_end_label, Vec::new()));
                    instr_vector.push(Instr::ICmp(v1.clone(), v2.clone()));
                    instr_vector.push(Instr::IMov(Val::Reg(Reg::RBX), Val::ImmInt(TRUE_INT)));
                    instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
                    instr_vector.push(Instr::ICmove(Val::Reg(Reg::RAX), Val::Reg(Reg::RBX)));
                }
                Op2::StructuralEquality => {

                  let index = if si % 2 == 0 { si + 2 } else { si + 3 };
                  let offset = index * 8;

                  let rdi_offset = 0;
                  let rsi_offset = 8;

                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RBX), Val::RegNegOffset(Reg::RSP, stack_offset)));

                  instr_vector.push(Instr::ISub(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));

                  instr_vector.push(Instr::IMov(Val::RegPlusOffset(Reg::RSP, rdi_offset), Val::Reg(Reg::RDI)));
                  instr_vector.push(Instr::IMov(Val::RegPlusOffset(Reg::RSP, rsi_offset), Val::Reg(Reg::RSI)));
        
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RDI), Val::Reg(Reg::RAX)));
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RSI), Val::Reg(Reg::RBX)));
        
                  instr_vector.push(Instr::ICall("snek_structural_equality".to_owned()));
        
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RDI), Val::RegPlusOffset(Reg::RSP, rdi_offset)));
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RSI), Val::RegPlusOffset(Reg::RSP, rsi_offset)));

                  instr_vector.push(Instr::IAdd(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));         

                }
                Op2::Greater => {
                    let greater_label = new_label(l, "greater");
                    let greater_end_label = new_label(l, "greater_end");

                    let v1 = Val::Reg(Reg::RAX);
                    let v2 = Val::RegNegOffset(Reg::RSP, stack_offset);
                    instr_vector.extend(is_num(v1.clone()));
                    instr_vector.extend(is_num(v2.clone()));

                    instr_vector.push(Instr::ICmp(v1.clone(), v2.clone()));
                    instr_vector.push(Instr::IJl(greater_label.clone())); // comparing 2nd with 1st param
                    instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
                    instr_vector.push(Instr::IJmp(greater_end_label.clone()));

                    let mut block_instrs = Vec::new();
                    block_instrs.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(TRUE_INT)));

                    instr_vector.push(Instr::ILabel(greater_label, block_instrs));
                    instr_vector.push(Instr::ILabel(greater_end_label, Vec::new()));
                }
                Op2::Less => { 

                  let less_label = new_label(l, "less");
                  let less_end_label = new_label(l, "less_end");

                  let v1 = Val::Reg(Reg::RAX);
                  let v2 = Val::RegNegOffset(Reg::RSP, stack_offset);
                  instr_vector.extend(is_num(v1.clone()));
                  instr_vector.extend(is_num(v2.clone()));

                  instr_vector.push(Instr::ICmp(v1.clone(), v2.clone()));
                  instr_vector.push(Instr::IJg(less_label.clone())); // comparing 2nd with 1st param
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
                  instr_vector.push(Instr::IJmp(less_end_label.clone()));

                  let mut block_instrs = Vec::new();
                  block_instrs.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(TRUE_INT)));

                  instr_vector.push(Instr::ILabel(less_label, block_instrs));
                  instr_vector.push(Instr::ILabel(less_end_label, Vec::new()));

                }
                Op2::GreaterEqual => {
                  let greater_eq_label = new_label(l, "greater_eq");
                  let greater_eq_end_label = new_label(l, "greater_eq_end");

                  let v1 = Val::Reg(Reg::RAX);
                  let v2 = Val::RegNegOffset(Reg::RSP, stack_offset);
                  instr_vector.extend(is_num(v1.clone()));
                  instr_vector.extend(is_num(v2.clone()));

                  instr_vector.push(Instr::ICmp(v1.clone(), v2.clone()));
                  instr_vector.push(Instr::IJle(greater_eq_label.clone())); // comparing 2nd with 1st param
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
                  instr_vector.push(Instr::IJmp(greater_eq_end_label.clone()));

                  let mut block_instrs = Vec::new();
                  block_instrs.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(TRUE_INT)));

                  instr_vector.push(Instr::ILabel(greater_eq_label, block_instrs));
                  instr_vector.push(Instr::ILabel(greater_eq_end_label, Vec::new()));
                }
                Op2::LessEqual => {
                  let less_eq_label = new_label(l, "less_eq");
                  let less_eq_end_label = new_label(l, "less_eq_end");

                  let v1 = Val::Reg(Reg::RAX);
                  let v2 = Val::RegNegOffset(Reg::RSP, stack_offset);
                  instr_vector.extend(is_num(v1.clone()));
                  instr_vector.extend(is_num(v2.clone()));

                  instr_vector.push(Instr::ICmp(v1.clone(), v2.clone()));
                  instr_vector.push(Instr::IJge(less_eq_label.clone())); // comparing 2nd with 1st param
                  instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
                  instr_vector.push(Instr::IJmp(less_eq_end_label.clone()));

                  let mut block_instrs = Vec::new();
                  block_instrs.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt(TRUE_INT)));

                  instr_vector.push(Instr::ILabel(less_eq_label, block_instrs));
                  instr_vector.push(Instr::ILabel(less_eq_end_label, Vec::new()));
                }
                Op2::CheckTypeMatch => {
                  let v1 = Val::Reg(Reg::RAX);
                  let v2 = Val::RegNegOffset(Reg::RSP, stack_offset);
                  let match_end_label = new_label(l, "check_type_match_end");
                  instr_vector.extend(check_type_match_result(v1.clone(), v2.clone(), &match_end_label));
                  instr_vector.push(Instr::ILabel(match_end_label, Vec::new()));
                }

            }
        }
        Expr::If(cond_exp, then_exp, else_exp) => {
          let end_label = new_label(l, "ifend");
          let else_label = new_label(l, "ifelse");
          let cond_instrs = compile_expr(cond_exp, si, &env, &break_label, l);
          let then_instrs = compile_expr(then_exp, si, &env, &break_label, l);
          let else_instrs = compile_expr(else_exp, si, &env, &break_label, l);
          instr_vector.extend(cond_instrs);
          instr_vector.push(Instr::ICmp(Val::Reg(Reg::RAX), Val::ImmInt(FALSE_INT)));
          instr_vector.push(Instr::IJe(else_label.clone()));
          instr_vector.extend(then_instrs);
          instr_vector.push(Instr::IJmp(end_label.clone()));
          instr_vector.push(Instr::ILabel(else_label, else_instrs));
          instr_vector.push(Instr::ILabel(end_label, Vec::new()));
        }
        Expr::Set(var_name, exp) => {
          let subexp_instrs = compile_expr(exp, si, &env, &break_label, l);
          instr_vector.extend(subexp_instrs);
          if env.contains_key(var_name) {
            let var_st_pos = *env.get(var_name).unwrap();
            instr_vector.push(Instr::IMov(Val::RegPlusOffset(Reg::RSP, var_st_pos), Val::Reg(Reg::RAX)));
          } else {
            panic!("Unbound variable identifier {}", var_name);
          }
        }
        Expr::Block(block_instrs_expr) => {
          for instr_expr in block_instrs_expr.iter() {
            instr_vector.extend(compile_expr(instr_expr, si, &env, &break_label, l));
          }
        }
        Expr::Loop(loop_instrs) => {

          let start_loop = new_label(l, "loop");
          let end_loop = new_label(l, "loopend");
          let loop_instrs = compile_expr(loop_instrs, si, &env, &end_loop, l);
          instr_vector.push(Instr::ILabel(start_loop.clone(), loop_instrs));
          instr_vector.push(Instr::IJmp(start_loop));
          instr_vector.push(Instr::ILabel(end_loop.clone(), Vec::new()));
        }
        Expr::Break(break_instrs) => {
          if break_label == "" {
            panic!("break outside loop");
          }
          instr_vector.extend(compile_expr(break_instrs, si, &env, &break_label, l));
          instr_vector.push(Instr::IJmp(break_label.clone()));
        },
        Expr::Function(fun_name, args_vec) => {
          let local_offset = si + (args_vec.len() as i32) + 1; // 1 for rdi
          let si_offset = if local_offset % 2 == 1 {local_offset} else {local_offset + 1}; // coz of call
          // let even_si_offset = if si_offset % 2 == 1 {si_offset + 1} else {si_offset};

          let offset = si_offset * 8;
          let mut curr_word_offset = offset;

          let mut si_local = si_offset;

          for arg in args_vec.iter() {
            let arg_instrs = compile_expr(arg, si_local, env, break_label, l); //todo
            instr_vector.extend(arg_instrs);
            instr_vector.push(Instr::IMov(Val::RegNegOffset(Reg::RSP, curr_word_offset), Val::Reg(Reg::RAX)));
            curr_word_offset -= 8;
            si_local += 1;
          }
          
          instr_vector.push(Instr::IMov(Val::RegNegOffset(Reg::RSP, curr_word_offset), Val::Reg(Reg::RDI)));
          
          instr_vector.push(Instr::ISub(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));

          instr_vector.push(Instr::ICall(fun_name.to_string()));

          instr_vector.push(Instr::IAdd(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));
          
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RDI), Val::RegNegOffset(Reg::RSP, curr_word_offset)));
          
        }, 
        Expr::Array(array_exprs) => {
          instr_vector.push(Instr::IComment("Array".to_string()));

          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::ImmInt((array_exprs.len() as i32).into()))); // size value to rax

          let addr_offset = (si + 1) * 8;

          // move [r15] into stack 
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RCX), Val::Reg(Reg::R15)));
          instr_vector.push(Instr::IMov(Val::RegNegOffset(Reg::RSP, addr_offset), Val::Reg(Reg::RCX)));

          let mut r15_offset = array_exprs.len() as i32 + 1;
          if r15_offset % 2 == 1 {r15_offset += 1};
          instr_vector.push(Instr::IAdd(Val::Reg(Reg::R15), Val::ImmInt((r15_offset * 8).into())));

          let mut offset = 0;
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RCX), Val::RegNegOffset(Reg::RSP, addr_offset)));
          instr_vector.push(Instr::IMov(Val::RegPlusOffset(Reg::RCX, offset * 8), Val::Reg(Reg::RAX)));
          offset += 1;

          let mut si_local = si + 2;
          for expr in array_exprs.iter() {
            instr_vector.extend(compile_expr(expr, si_local, &env, &break_label, l));
            instr_vector.push(Instr::IMov(Val::Reg(Reg::RCX), Val::RegNegOffset(Reg::RSP, addr_offset)));
            instr_vector.push(Instr::IMov(Val::RegPlusOffset(Reg::RCX, offset * 8), Val::Reg(Reg::RAX)));
            offset += 1;
            si_local += 1;
          }

          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::RegNegOffset(Reg::RSP, addr_offset)));
          instr_vector.push(Instr::IAdd(Val::Reg(Reg::RAX), Val::ImmInt(ARRAY_TAG_INT)));
        },
        Expr::GetArrayIndex(addr_expr, index_expr) => {
          
          instr_vector.extend(evaluate_addr_and_index_array(si, addr_expr, index_expr, &env, &break_label, l));

          instr_vector.extend(access_array_index_addr(si));
          
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::RegPlusOffset(Reg::RBX, 0))); // address value
        }
        Expr::SetArrayIndex(addr_expr, index_expr, value_expr) => {

          let stack_offset = si * 8;

          instr_vector.extend(evaluate_addr_and_index_array(si, addr_expr, index_expr, &env, &break_label, l));

          instr_vector.extend(compile_expr(value_expr, si + 2, &env, &break_label, l)); 
          instr_vector.push(Instr::IMov(Val::RegNegOffset(Reg::RSP, stack_offset + 16), Val::Reg(Reg::RAX)));

          instr_vector.extend(access_array_index_addr(si));

          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::RegNegOffset(Reg::RSP, stack_offset + 16))); // value

          instr_vector.push(Instr::IMov(Val::RegPlusOffset(Reg::RBX, 0), Val::Reg(Reg::RAX))); 

          // return in RAX the start address of array along with pair tag
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::RegNegOffset(Reg::RSP, stack_offset))); 
          instr_vector.push(Instr::IAdd(Val::Reg(Reg::RAX), Val::ImmInt(ARRAY_TAG_INT)));
        }
        Expr::GetArraySize(addr_expr) => {
          instr_vector.extend(evaluate_addr(si + 1, addr_expr, &env, &break_label, l));

          let stack_offset = (si + 1) * 8;

          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::RegNegOffset(Reg::RSP, stack_offset))); // address value
          instr_vector.push(Instr::IMov(Val::Reg(Reg::RBX), Val::RegNegOffset(Reg::RAX, 0))); // actual value = size of array

          // represent as num
          instr_vector.push(Instr::ISal(Val::Reg(Reg::RBX), 1));

          instr_vector.push(Instr::IMov(Val::Reg(Reg::RAX), Val::Reg(Reg::RBX))); // size value
        }
    }
    instr_vector.to_vec()
}

fn compile_definition(d: &Definition, labels: &mut i32) -> Vec<Instr> {
  let mut instr_vector = Vec::new();

  let si = 0;
  let mut env = im::HashMap::<String, i32>::new();
  let break_label = "";

  let body = &d.fun_body.clone().unwrap();
  let depth = depth(&body);
  let depth = if depth % 2 == 0 { depth } else { depth + 1 };
  let offset = depth * 8;

  // let total_depth = depth + (d.args.len() as i32);
  // let total_depth = if total_depth % 2 == 0 { total_depth } else { total_depth + 1 };
  // let offset = total_depth * 8;

  for (i, arg) in d.args.iter().enumerate() {
    env.insert(arg.clone(), (depth + (i as i32 + 1)) * 8);
  }

  let mut body_instrs = Vec::new();
  body_instrs.push(Instr::ISub(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));
  body_instrs.extend(compile_expr(&body, si, &env, &break_label.to_owned(), labels));
  body_instrs.push(Instr::IAdd(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));

  instr_vector.push(Instr::ILabel(d.fun_name.to_owned(), body_instrs));

  instr_vector.push(Instr::IRet());

  instr_vector
}

fn compile_prog(prog: &Program) -> (String, String) {

  let si = 0;
  let env = im::HashMap::<String, i32>::new();
  let mut labels = 0;
  let break_label = "";

  let mut defs_instr_vector : Vec<Instr> = Vec::new();
  for def in &prog.defs[..] {
    defs_instr_vector.extend(compile_definition(&def, &mut labels));
  }

  let depth = depth(&prog.main.clone());
  let total_depth = if depth % 2 == 0 { depth } else { depth + 1 };
  let offset = total_depth * 8;

  let main_body_instrs = compile_expr(&prog.main, si, &env, &break_label.to_owned(), &mut labels);

  let mut main_instr_vect = Vec::new();
  main_instr_vect.push(Instr::ISub(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));
  main_instr_vect.extend(main_body_instrs);
  main_instr_vect.push(Instr::IAdd(Val::Reg(Reg::RSP), Val::ImmInt(offset.into())));

  (decode_instrs_vec_to_string(&defs_instr_vector), decode_instrs_vec_to_string(&main_instr_vect))
}

fn compile_error_defs() -> String {
  // write assembly instructions to align the code before snek_error is called
  //todo: check
  return "throw_error:
          mov rdi, 7
          push rsp

          MOV RAX, RSP ; Move the current stack pointer value to RAX
          AND RAX, 0xF ; Bitwise AND with 0xF to get the remainder when divided by 16
          CMP RAX, 0 ; Compare the remainder with 0 to check if it is 16 byte aligned
          JE aligned_throw_error ; If aligned, jump to the aligned label
          SUB RSP, 8 ; If not aligned, decrement RSP by 8 bytes to make it aligned
          JMP aligned_throw_error

          aligned_throw_error:
          call snek_error
          ret

          throw_overflow_error:
          mov rdi, 8
          push rsp

          MOV RAX, RSP ; Move the current stack pointer value to RAX
          AND RAX, 0xF ; Bitwise AND with 0xF to get the remainder when divided by 16
          CMP RAX, 0 ; Compare the remainder with 0 to check if it is 16 byte aligned
          JE aligned_throw_error ; If aligned, jump to the aligned label
          SUB RSP, 8 ; If not aligned, decrement RSP by 8 bytes to make it aligned
          JMP aligned_throw_error

          throw_index_out_of_bounds_error:
          mov rdi, 9
          push rsp

          MOV RAX, RSP ; Move the current stack pointer value to RAX
          AND RAX, 0xF ; Bitwise AND with 0xF to get the remainder when divided by 16
          CMP RAX, 0 ; Compare the remainder with 0 to check if it is 16 byte aligned
          JE aligned_throw_error ; If aligned, jump to the aligned label
          SUB RSP, 8 ; If not aligned, decrement RSP by 8 bytes to make it aligned
          JMP aligned_throw_error

          ".to_string();
}


// parsing 

fn parse_bind(s: &Sexp,defs: &Vec<Definition>) -> Vec<(String, Expr)> {
    let mut bindings_vec = Vec::new();
    match s {
        Sexp::List(bindings) => {
            for binding in bindings.iter() {
                let current_binding = match binding {
                    Sexp::List(binding) => {
                        match &binding[..] {
                            [Sexp::Atom(S(id)), subexp] => {
                              if ALL_RESERVED_WORDS.contains(&&id[..]) {
                                panic!("let binding contains a keyword");
                              } else {
                                vec![(id.to_string(), parse_expr(subexp, &defs))]
                              }
                            }
                            _ => panic!("Invalid"),  
                        }
                    }  
                    _ => panic!("Invalid"),
                };
                bindings_vec.extend(current_binding);
                println!("bindings_vec {:?}", bindings_vec);
            }
            bindings_vec
        }
        _ => panic!("Invalid"),
    }

}

fn is_def(s: &Sexp) -> bool {
  match s {
    Sexp::List(vec) => match &vec[..] {
      [Sexp::Atom(S(fun_keyword)), Sexp::List(_), _] if fun_keyword == "fun" => true, 
      _ => false,
    }, 
    _ => false
  }
}

fn parse_def(s: &Sexp, defined_function_names: &mut HashSet<String>) -> (Definition, Sexp) {
  match s {
    Sexp::List(vec) => match &vec[..] {
      [Sexp::Atom(S(fun_keyword)), Sexp::List(fun_def), fun_body_sexp] 
        if fun_keyword == "fun" => match &fun_def[..] {
          [Sexp::Atom(S(fun_name)), args @ ..] => {

            if ALL_RESERVED_WORDS.contains(&&fun_name[..]) {
              panic!("fun_name contains a keyword: Invalid");
            }

            if defined_function_names.contains(fun_name) {
              panic!("Multiple functions are defined with the same name: Invalid");
            }

            let mut arg_names = HashSet::new();
            let mut args_vec = Vec::<String>::new();
            for arg in args.iter() {
              if let Sexp::Atom(S(arg_name)) = arg {
                // println!("arg in args - {}", arg_name);

                if ALL_RESERVED_WORDS.contains(&&arg_name[..]) {
                  panic!("arg_name contains a keyword: Invalid");
                }

                if arg_names.contains(arg_name) {
                  panic!("A function's parameter list has a duplicate name: Invalid");
                }
                arg_names.insert(arg_name);
                args_vec.push(arg_name.to_string());
              }
            }
          
            defined_function_names.insert(fun_name.to_string());
            // let mut defs_local = defs.clone();
            // let mut current_definition = Definition {
            let current_definition = Definition {
              fun_name: fun_name.to_string(),
              args: args_vec, 
              fun_body: None,
              // fun_body: FunBody::FunBodySexp(fun_body_sexp.clone()),
            };
            // defs_local.push(current_definition.clone());
            // current_definition.fun_body = parse_expr(fun_body_sexp, &defs_local);
            return (current_definition, fun_body_sexp.clone());
          }, 
        _ => panic!("Function definition not valid: Invalid"),
      },
      _ => panic!("Program should have fun_keyword, fun_defs_list and fun_body: Invalid"),
    }, 
    _ => panic!("Program needs to be a list: Invalid"),
  }
}

fn parse_def_body(defs : &Vec<Definition>, fun_body_sexp_hashmap: &HashMap<String, Sexp>) -> Vec<Definition> {
  let mut defs_local : Vec<Definition> = vec![];
  for def in defs {
    if fun_body_sexp_hashmap.contains_key(&def.fun_name) {
      let fun_body_sexp = fun_body_sexp_hashmap.get(&def.fun_name).unwrap();
      let fun_body = parse_expr(fun_body_sexp, &defs);
      
      if has_input_type(&fun_body) {
        panic!("Function body has input type: Invalid");
      }

      defs_local.push(Definition {
        fun_name: def.fun_name.to_owned(),
        args: def.args.to_owned(),
        fun_body: Some(parse_expr(fun_body_sexp, &defs)),
      })
    } else {
      panic!("Function not defined: Invalid");
    }
  }
  return defs_local;
}

fn parse_expr(s: &Sexp,defs: &Vec<Definition>) -> Expr {
    match s {
        Sexp::Atom(I(n)) => {
          match i64::try_from(*n) {
            Ok(num) => {
              if num > I63_MAX || num < I63_MIN {
                panic!("Invalid: num can't fit in 63 bits")
              } else {
                Expr::Number(i64::try_from(num << 1).unwrap())
              }
            },
            Err(_) => panic!("Invalid: num can't fit in 63 bits")
          }
        },
        Sexp::Atom(S(id)) => {
            match id.as_ref() {
                "let" | "add1" | "sub1" => panic!("Invalid"),
                "true" => Expr::True,
                "false" => Expr::False,
                "input" => Expr::Input,
                "nil" => Expr::Nil,
                _ => Expr::Id(id.to_string()),
            }
        },
        Sexp::List(vec) => {
            match &vec[..] {
                [Sexp::Atom(S(op)), e] if op == "add1" => Expr::UnOp(Op1::Add1, Box::new(parse_expr(e, &defs))),
                [Sexp::Atom(S(op)), e] if op == "sub1" => Expr::UnOp(Op1::Sub1, Box::new(parse_expr(e, &defs))),
                [Sexp::Atom(S(op)), e] if op == "isnum" => Expr::UnOp(Op1::IsNum, Box::new(parse_expr(e, &defs))),
                [Sexp::Atom(S(op)), e] if op == "isbool" => Expr::UnOp(Op1::IsBool, Box::new(parse_expr(e, &defs))),
                [Sexp::Atom(S(op)), e] if op == "isnil" => Expr::UnOp(Op1::IsNil, Box::new(parse_expr(e, &defs))),
                [Sexp::Atom(S(op)), e] if op == "print" => Expr::UnOp(Op1::Print, Box::new(parse_expr(e, &defs))),
                [Sexp::Atom(S(op)), e] if op == "loop" => Expr::Loop(Box::new(parse_expr(e, &defs))),
                [Sexp::Atom(S(op)), e] if op == "break" => Expr::Break(Box::new(parse_expr(e, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == "let" => Expr::Let(parse_bind(e1, &defs), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == "+" => Expr::BinOp(Op2::Plus, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == "-" => Expr::BinOp(Op2::Minus, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == "*" => Expr::BinOp(Op2::Times, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == "=" => Expr::BinOp(Op2::Equal, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == "==" => Expr::BinOp(Op2::StructuralEquality, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == ">" => Expr::BinOp(Op2::Greater, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == "<" => Expr::BinOp(Op2::Less, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == ">=" => Expr::BinOp(Op2::GreaterEqual, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), e1, e2] if op == "<=" => Expr::BinOp(Op2::LessEqual, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),

                [Sexp::Atom(S(op)), cond_exp, then_exp, else_exp] if op == "if" =>
                   Expr::If(Box::new(parse_expr(cond_exp, &defs)), 
                                            Box::new(parse_expr(then_exp, &defs)), 
                                            Box::new(parse_expr(else_exp, &defs))),

                [Sexp::Atom(S(op)), Sexp::Atom(S(id)), exp] if op == "set!" => {
                  if ALL_RESERVED_WORDS.contains(&&id[..]) {
                    panic!("set binding contains a keyword");
                  } else {
                    Expr::Set(id.to_string(), Box::new(parse_expr(exp, &defs)))
                  }
                }
                [Sexp::Atom(S(op)), rest @ ..] if op == "block" => {
                  if rest.len() == 0 {
                    panic!("Invalid syntax");
                  }
                  let mut block_exps = Vec::new();
                  for sub_exp in rest.iter() {
                    block_exps.push(parse_expr(sub_exp, &defs));
                  }
                  Expr::Block(block_exps)
                }
                [Sexp::Atom(S(fun_name)), rest @ ..] 
                  if defs.iter().any(|def| def.fun_name == fun_name.to_string() && def.args.len() == rest.len()) => {
                    Expr::Function(fun_name.to_string(), 
                      rest.iter().map(|arg_val| parse_expr(arg_val, &defs)).collect())
                }
                [Sexp::Atom(S(op)), e1, e2] if op == "checkTypeMatch" => 
                      Expr::BinOp(Op2::CheckTypeMatch, Box::new(parse_expr(e1, &defs)), Box::new(parse_expr(e2, &defs))),
                [Sexp::Atom(S(op)), rest @ ..] if op == "array" => {
                  let mut list_vals = Vec::new();
                  for sub_exp in rest.iter() {
                    if let Sexp::Atom(S(array_val)) = sub_exp {
                      if ALL_RESERVED_WORDS.contains(&&array_val[..]) {
                        panic!("array binding contains a keyword");
                      }
                    }
                    list_vals.push(parse_expr(sub_exp, &defs));
                  }
                  Expr::Array(list_vals)
                }
                [Sexp::Atom(S(op)), address_expr, index_expr] if op == "getIndex" => {
                  Expr::GetArrayIndex(Box::new(parse_expr(address_expr, &defs)), 
                                      Box::new(parse_expr(index_expr, &defs)))
                }
                [Sexp::Atom(S(op)), address_expr, index_expr, value_expr] if op == "setIndex" => {
                  Expr::SetArrayIndex(Box::new(parse_expr(address_expr, &defs)), 
                                      Box::new(parse_expr(index_expr, &defs)), 
                                      Box::new(parse_expr(value_expr, &defs)))
                }
                [Sexp::Atom(S(op)), address_expr] if op == "getSize" => {
                  Expr::GetArraySize(Box::new(parse_expr(address_expr, &defs)))
                }
                _ => panic!("Invalid: Did not match any defined list operations {:?}", vec)
            }
        },
        _ => panic!("Invalid: Did not match any sexp type")

    }
}

fn parse_prog(s: &Sexp) -> Program {
  let mut defined_function_names : HashSet<String> = HashSet::new();
  let mut found_main = false;
  let mut parsed_prog = None;

  match s {
    Sexp::List(vec) => {
      let mut defs: Vec<Definition> = vec![];
      let mut fun_body_sexp_hashmap: HashMap<String, Sexp> = HashMap::new();
      for def_or_expr in vec {
        if is_def(def_or_expr) {
          if found_main {
            panic!("Main function should be the last function: Invalid");
          }
          let (current_definition, current_body_sexp) = parse_def(def_or_expr, &mut defined_function_names);
          defs.push(current_definition.clone());
          fun_body_sexp_hashmap.insert(current_definition.fun_name.to_owned(), current_body_sexp);
        } else {
          parsed_prog = Some(Program {
            defs: parse_def_body(&defs, &fun_body_sexp_hashmap),
            main: parse_expr(def_or_expr, &defs),
          });
          found_main = true;
        }
      }
      // if main_expr.is_some() {
      //   return Program {
      //     defs: parse_def_body(&defs, fun_body_sexp_hashmap),
      //     main: parse_expr(main_expr.unwrap(), &defs),
      //   };
      // }
      if found_main {
        return parsed_prog.unwrap();
      } else {
        panic!("No main found: Invalid");
      }
      
    }
    _ => panic!("Program needs to be a list: Invalid"),
  }
}



// -------




fn main() -> std::io::Result<()> {
    let args: Vec<String> = env::args().collect();

    let in_name = &args[1];
    let out_name = &args[2];

    let mut in_file = File::open(in_name)?;
    let mut contents = String::new();
    in_file.read_to_string(&mut contents)?;

    let prog = "(".to_owned() + &contents + ")";

    let s_exp = match parse(&prog) {
        Ok(s_exp) => s_exp,
        Err(_) => panic!("Invalid")
    };

    println!("s_exp - {}", s_exp);
    let prog = parse_prog(&s_exp);
    println!("parse_prog - {:?}", prog);

    let (defs, main) = compile_prog(&prog);
    let error_defs = compile_error_defs();
    // let result = "mov rax, 1";

    let asm_program = format!(
        "
          section .text
          global our_code_starts_here
          extern snek_print
          extern snek_error
          extern snek_structural_equality

          {}

          {}

          our_code_starts_here:
          mov r15, rsi
            {}
            ret
          ",
          error_defs,
          defs,
          main
      );

    let mut out_file = File::create(out_name)?;
    out_file.write_all(asm_program.as_bytes())?;

    Ok(())
}